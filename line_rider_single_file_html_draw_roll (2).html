<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Line Rider – Advanced (Fix: Clickable UI, Anti‑Tunneling)</title>
  <style>
    :root{ --bg:#0b0e14; --panel:#121722; --ink:#e8e8e8; --b:#1f2533; --blue:#60a5fa; --red:#ef4444; --yellow:#f59e0b; --vio:#a78bfa; --good:#34d399; --pink:#f472b6; }
    html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #canvas{position:fixed;inset:0;width:100vw;height:100dvh;display:block;touch-action:none;background:#000;z-index:0}
    #ui{position:fixed;left:12px;top:12px;display:flex;flex-wrap:wrap;gap:8px;z-index:1000;pointer-events:auto}
    #ui *{pointer-events:auto}
    .group{display:flex;gap:6px;background:#0f1420;border:1px solid var(--b);padding:6px;border-radius:12px;align-items:center}
    .btn{background:var(--panel);border:1px solid var(--b);color:var(--ink);padding:8px 10px;border-radius:10px;cursor:pointer;font-size:14px;user-select:none}
    .btn[aria-pressed="true"]{outline:2px solid #59c}
    .swatch{width:12px;height:12px;border-radius:3px;display:inline-block;border:1px solid var(--b)}
    #hud{position:fixed;right:12px;top:12px;background:var(--panel);padding:8px 10px;border-radius:10px;border:1px solid var(--b);font-size:12px;opacity:.9;z-index:1000}
    #overlay{position:fixed;left:50%;top:16px;transform:translateX(-50%);background:rgba(15,20,32,.8);padding:6px 10px;border-radius:10px;border:1px solid var(--b);font-size:12px;z-index:1000}
    .badge{padding:2px 6px;border-radius:6px;border:1px solid var(--b);background:#0f1420;margin-left:6px;font-size:11px}
    #err{position:fixed;left:12px;bottom:12px;background:#7f1d1d;color:#fee;padding:8px 10px;border-radius:8px;border:1px solid #991b1b;display:none;z-index:1001;max-width:min(90vw,520px);font-size:12px;white-space:pre-wrap}
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="ui">
    <div class="group" role="toolbar" aria-label="Modes">
      <button class="btn" id="drawBtn" aria-pressed="true">Draw</button>
      <button class="btn" id="playBtn">Play</button>
      <button class="btn" id="moveBtn">Move</button>
      <button class="btn" id="startBtn">Set Start</button>
      <button class="btn" id="endBtn">Set End</button>
      <button class="btn" id="resetBtn">Reset</button>
    </div>
    <div class="group" role="toolbar" aria-label="Tools">
      <button class="btn" id="toolFree" aria-pressed="true">Freihand</button>
      <button class="btn" id="toolLine">Gerade</button>
      <button class="btn" id="toolArcC">Kreisbogen</button>
      <button class="btn" id="toolArcO">Ovalbogen</button>
      <button class="btn" id="toolErase">Eraser</button>
    </div>
    <div class="group" role="toolbar" aria-label="Effect">
      <span>Effekt:</span>
      <button class="btn" id="effNeutral" aria-pressed="true">Neutral <span class="swatch" style="background:var(--blue)"></span></button>
      <button class="btn" id="effBoost">Boost <span class="swatch" style="background:var(--red)"></span></button>
      <button class="btn" id="effBrake">Brake <span class="swatch" style="background:var(--yellow)"></span></button>
      <button class="btn" id="effGrav">Gravity <span class="swatch" style="background:var(--vio)"></span></button>
    </div>
  </div>

  <div id="overlay">Draw: Freihand/Gerade/Kreis/Oval · Effekt: Neutral/Boost/Brake/Gravity · <b>Move</b>: 2‑Finger Zoom & Pan · Set Start/End · Play</div>
  <div id="hud">FPS: <span id="fps">0</span> <span id="finish" class="badge" style="display:none">Goal!</span></div>
  <div id="err"></div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.floor(devicePixelRatio || 1));
  const errBox = document.getElementById('err');

  // Simple runtime error display to avoid "nothing works" situations
  window.addEventListener('error', (e)=>{ errBox.textContent = 'Fehler: '+ e.message; errBox.style.display='block'; });

  const el = id => document.getElementById(id);
  const drawBtn = el('drawBtn'), playBtn = el('playBtn'), moveBtn = el('moveBtn'), startBtn = el('startBtn'), endBtn = el('endBtn'), resetBtn = el('resetBtn');
  const toolFree = el('toolFree'), toolLine = el('toolLine'), toolArcC = el('toolArcC'), toolArcO = el('toolArcO'), toolErase = el('toolErase');
  const effNeutral = el('effNeutral'), effBoost = el('effBoost'), effBrake = el('effBrake'), effGrav = el('effGrav');
  const fpsOut = el('fps'); const finishBadge = el('finish');

  // State
  let mode = 'draw';        // 'draw' | 'play' | 'move' | 'setstart' | 'setend'
  let tool = 'free';        // 'free' | 'line' | 'arcc' | 'arco' | 'eraser'
  let effect = 'neutral';   // 'neutral' | 'boost' | 'brake' | 'gravity'

  // View
  const view = { x:0, y:0, scale:1 };

  // Geometry Model
  // stroke = { type:'neutral'|'boost'|'brake'|'gravity', points:[{x,y}...], shape:'poly'|'arcC'|'arcO' }
  let strokes = [];

  // In-progress drawing
  let drawing = false;        // free/line temp
  let tempPoints = null;      // for freehand or line [start, current]
  // Circle arc: 3-points (start, end, via/bulge)
  let arcStage = 0;           // 0 idle, 1 choose end, 2 adjust bulge
  let arcS=null, arcE=null, arcV=null; // S/E/Via (on-arc for circle)

  // Ball & Physics
  const ball = { r: 10, pos:{x:200,y:200}, vel:{x:0,y:0}, trail:[] };
  const phys = {
    g: 30,            // gravity
    restitution: 0.4, // bounciness
    fric: 0.04,       // surface friction
    slopeGain: 1.2,
    uphillDamp: 1.2,
    boostAccel: 2400,
    brakeRate: 2.2,
    gravityRange: 140,
    gravityStrength: 1800,
    maxSub: 16,
    worldPad: 2000,
  };

  // Markers
  let startMarker = {x: 130, y: 190};
  let endMarker = null; // set by user

  // Helpers
  function resize(){ const w = Math.floor(innerWidth*DPR), h = Math.floor((innerHeight||document.documentElement.clientHeight)*DPR); if (canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h; } }
  function worldPt(px,py){ const r=canvas.getBoundingClientRect(); const x=(px-r.left)*canvas.width/r.width, y=(py-r.top)*canvas.height/r.height; return { x:(x/DPR)/view.scale + view.x, y:(y/DPR)/view.scale + view.y }; }
  function mix(a,b,t){ return {x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t}; }
  const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
  function nearestOnSeg(p,a,b){ const abx=b.x-a.x, aby=b.y-a.y; const ab2=abx*abx+aby*aby||1; const apx=p.x-a.x, apy=p.y-a.y; let t=(apx*abx+apy*aby)/ab2; t=Math.max(0,Math.min(1,t)); return {x:a.x+abx*t,y:a.y+aby*t,t}; }

  function quadSample(p0,p1,p2,n=24){ const out=[]; for(let i=0;i<=n;i++){ const t=i/n; const u=1-t; out.push({x:u*u*p0.x+2*u*t*p1.x+t*t*p2.x,y:u*u*p0.y+2*u*t*p1.y+t*t*p2.y}); } return out; }

  function circleArcFromSEV(S,E,V,samples=48){
    const x1=S.x,y1=S.y,x2=E.x,y2=E.y,x3=V.x,y3=V.y;
    const a = x1*(y2-y3)-y1*(x2-x3)+x2*y3-x3*y2;
    const b = (x1*x1+y1*y1)*(y3-y2)+(x2*x2+y2*y2)*(y1-y3)+(x3*x3+y3*y3)*(y2-y1);
    const c = (x1*x1+y1*y1)*(x2-x3)+(x2*x2+y2*y2)*(x3-x1)+(x3*x3+y3*y3)*(x1-x2);
    const d = (x1*x1+y1*y1)*(x3*y2 - x2*y3)+(x2*x2+y2*y2)*(x1*y3 - x3*y1)+(x3*x3+y3*y3)*(x2*y1 - x1*y2);
    if (Math.abs(a) < 1e-6) { return quadSample(S, V, E, samples); }
    const cx = -b/(2*a), cy = -c/(2*a); const r = Math.sqrt((b*b+c*c-4*a*d)/(4*a*a))||1;
    const ang = p=>Math.atan2(p.y - cy, p.x - cx);
    let a1 = ang(S), a2 = ang(E), av = ang(V);
    function norm(d){ while(d<=-Math.PI)d+=2*Math.PI; while(d>Math.PI)d-=2*Math.PI; return d; }
    let d12 = norm(a2-a1), d1v = norm(av-a1);
    let dir = Math.sign(d12) || 1; if ((dir>0 && !(d1v>=0 && d1v<=Math.abs(d12))) || (dir<0 && !(d1v<=0 && d1v>=-Math.abs(d12)))) dir = -dir;
    const out=[]; for(let i=0;i<=samples;i++){ const t=i/samples; const angt = a1 + dir * Math.abs(d12) * t; out.push({x: cx + r*Math.cos(angt), y: cy + r*Math.sin(angt)}); }
    return out;
  }

  function ovalArcFromSEV(S,E,V,samples=48){
    const M = mix(S,E,0.5); const dx=E.x-S.x, dy=E.y-S.y; const L = Math.hypot(dx,dy)||1;
    const ux = dx/L, uy = dy/L; const px = -uy, py = ux; const vRel = { x:(V.x-M.x), y:(V.y-M.y) };
    const b = Math.abs(vRel.x*px + vRel.y*py); const a = L/2; const sign = Math.sign(vRel.x*px + vRel.y*py) || 1;
    const out=[]; for (let i=0;i<=samples;i++){ const t = -1 + 2*i/samples; const ex = M.x + t*a*ux + sign * (b*Math.sqrt(Math.max(0,1 - (t*t))))*px; const ey = M.y + t*a*uy + sign * (b*Math.sqrt(Math.max(0,1 - (t*t))))*py; out.push({x:ex,y:ey}); } return out;
  }

  function buildSegments(){
    const segs=[];
    for (let si=0; si<strokes.length; si++){
      const s = strokes[si]; const P = s.points; if (!P || P.length<2) continue;
      for (let i=0;i<P.length-1;i++) segs.push({ a:P[i], b:P[i+1], type:s.type, si });
    }
    return segs;
  }

  // Input & gestures
  const pointers = new Map();
  const pinch = {active:false, d:0, mid:{x:0,y:0}};

  canvas.addEventListener('pointerdown', (e)=>{
    // allow UI to be clickable: do nothing if target is button
    if (e.target !== canvas) return;
    canvas.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

    if (mode==='draw'){
      const w = worldPt(e.clientX, e.clientY);
      if (tool==='free') { drawing=true; tempPoints=[w]; }
      else if (tool==='line') { drawing=true; tempPoints=[w,w]; }
      else if (tool==='arcc') { if (arcStage===0){ arcS=w; arcE=w; arcV=w; arcStage=1; } }
      else if (tool==='arco') { if (arcStage===0){ arcS=w; arcE=w; arcV=w; arcStage=1; } }
      else if (tool==='eraser') { eraseAt(w); }
    } else if (mode==='setstart'){
      const w = worldPt(e.clientX, e.clientY); startMarker = {x:w.x,y:w.y}; mode='draw'; updateButtons();
    } else if (mode==='setend'){
      const w = worldPt(e.clientX, e.clientY); endMarker = {x:w.x,y:w.y}; mode='draw'; updateButtons();
    } else if (mode==='move'){
      if (pointers.size===2){ const pts=[...pointers.values()]; const dx=pts[0].x-pts[1].x, dy=pts[0].y-pts[1].y; pinch.d=Math.hypot(dx,dy)||1; pinch.mid={x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2}; pinch.active=true; }
    }
  });

  // Buttons must handle their own clicks
  document.getElementById('ui').addEventListener('click', (e)=>{
    const id = (e.target.closest('button')||{}).id;
    if (!id) return;
    switch(id){
      case 'drawBtn': mode='draw'; break;
      case 'playBtn': mode='play'; finishBadge.style.display='none'; break;
      case 'moveBtn': mode='move'; break;
      case 'startBtn': mode='setstart'; break;
      case 'endBtn': mode='setend'; break;
      case 'resetBtn': ball.vel={x:0,y:0}; ball.trail=[]; ball.pos={...startMarker}; finishBadge.style.display='none'; break;
      case 'toolFree': tool='free'; arcStage=0; break;
      case 'toolLine': tool='line'; arcStage=0; break;
      case 'toolArcC': tool='arcc'; arcStage=0; break;
      case 'toolArcO': tool='arco'; arcStage=0; break;
      case 'toolErase': tool='eraser'; arcStage=0; break;
      case 'effNeutral': effect='neutral'; break;
      case 'effBoost': effect='boost'; break;
      case 'effBrake': effect='brake'; break;
      case 'effGrav': effect='gravity'; break;
    }
    updateButtons();
  });

  canvas.addEventListener('pointermove', (e)=>{
    if (e.target !== canvas) return;
    const prev = pointers.get(e.pointerId); pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
    const w = worldPt(e.clientX, e.clientY);

    if (mode==='draw'){
      if (tool==='free' && drawing && tempPoints){ const last=tempPoints[tempPoints.length-1]; const dx=w.x-last.x, dy=w.y-last.y; if (dx*dx+dy*dy>4) tempPoints.push(w); }
      else if (tool==='line' && drawing && tempPoints){ tempPoints[1]=w; }
      else if (tool==='arcc'){ if (arcStage===1){ arcE=w; } else if (arcStage===2){ arcV=w; } }
      else if (tool==='arco'){ if (arcStage===1){ arcE=w; } else if (arcStage===2){ arcV=w; } }
    } else if (mode==='move'){
      if (pointers.size>=2){
        const pts=[...pointers.values()]; const dx=pts[0].x-pts[1].x, dy=pts[0].y-pts[1].y; const dist=Math.hypot(dx,dy)||1; const mid={x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2};
        if (pinch.active){ view.x -= (mid.x - pinch.mid.x)/(view.scale); view.y -= (mid.y - pinch.mid.y)/(view.scale); }
        const worldBefore = worldPt(mid.x, mid.y); const factor = pinch.active ? (dist/pinch.d) : 1; view.scale = Math.max(0.2, Math.min(4, view.scale*factor));
        const worldAfter = worldPt(mid.x, mid.y); view.x += (worldBefore.x - worldAfter.x); view.y += (worldBefore.y - worldAfter.y);
        pinch.d=dist; pinch.mid=mid; pinch.active=true;
      } else if (prev) { const dx=e.clientX-prev.x, dy=e.clientY-prev.y; view.x -= dx/(view.scale); view.y -= dy/(view.scale); pinch.active=false; }
    }
  });

  canvas.addEventListener('pointerup', (e)=>{
    if (e.target !== canvas) return;
    pointers.delete(e.pointerId);
    const w = worldPt(e.clientX, e.clientY);

    if (mode==='draw'){
      if (tool==='free' && drawing && tempPoints){ if (tempPoints.length>1) strokes.push({type:effect, points: tempPoints.slice(), shape:'poly'}); drawing=false; tempPoints=null; }
      else if (tool==='line' && drawing && tempPoints){ const pts=[tempPoints[0], tempPoints[1]]; if (dist(pts[0],pts[1])>2) strokes.push({type:effect, points: pts, shape:'poly'}); drawing=false; tempPoints=null; }
      else if (tool==='arcc'){
        if (arcStage===1){ arcE=w; arcStage=2; arcV = mix(arcS, arcE, 0.5); }
        else if (arcStage===2){ arcV=w; const pts = circleArcFromSEV(arcS, arcE, arcV, 60); if (pts.length>1) strokes.push({type:effect, points: pts, shape:'arcC'}); arcStage=0; }
      }
      else if (tool==='arco'){
        if (arcStage===1){ arcE=w; arcStage=2; arcV = mix(arcS, arcE, 0.5); }
        else if (arcStage===2){ arcV=w; const pts = ovalArcFromSEV(arcS, arcE, arcV, 60); if (pts.length>1) strokes.push({type:effect, points: pts, shape:'arcO'}); arcStage=0; }
      }
    } else if (mode==='move'){
      if (pointers.size<2) pinch.active=false;
    }
  });

  canvas.addEventListener('pointercancel', ()=>{ pointers.clear(); drawing=false; tempPoints=null; arcStage=0; pinch.active=false; });

  // Desktop wheel zoom always allowed
  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const factor=Math.pow(1.0015,-e.deltaY);
    const mx=e.clientX,my=e.clientY; const before=worldPt(mx,my);
    view.scale=Math.max(0.2,Math.min(4,view.scale*factor));
    const after=worldPt(mx,my); view.x += (before.x - after.x); view.y += (before.y - after.y);
  }, {passive:false});

  function eraseAt(w){
    const threshold = 12; let best={si:-1, d2:Infinity};
    for (let si=0; si<strokes.length; si++){
      const P = strokes[si].points; for (let i=0;i<P.length-1;i++){
        const q=nearestOnSeg(w,P[i],P[i+1]); const dx=w.x-q.x, dy=w.y-q.y; const d2=dx*dx+dy*dy; if (d2<best.d2){ best={si,d2}; }
      }
    }
    if (best.si>=0 && best.d2 < threshold*threshold){ strokes.splice(best.si,1); }
  }

  // Buttons state visuals
  function updateButtons(){
    drawBtn.setAttribute('aria-pressed', String(mode==='draw'));
    playBtn.setAttribute('aria-pressed', String(mode==='play'));
    moveBtn.setAttribute('aria-pressed', String(mode==='move'));
    startBtn.setAttribute('aria-pressed', String(mode==='setstart'));
    endBtn.setAttribute('aria-pressed', String(mode==='setend'));

    toolFree.setAttribute('aria-pressed', String(tool==='free'));
    toolLine.setAttribute('aria-pressed', String(tool==='line'));
    toolArcC.setAttribute('aria-pressed', String(tool==='arcc'));
    toolArcO.setAttribute('aria-pressed', String(tool==='arco'));
    toolErase.setAttribute('aria-pressed', String(tool==='eraser'));

    effNeutral.setAttribute('aria-pressed', String(effect==='neutral'));
    effBoost.setAttribute('aria-pressed', String(effect==='boost'));
    effBrake.setAttribute('aria-pressed', String(effect==='brake'));
    effGrav.setAttribute('aria-pressed', String(effect==='gravity'));
  }

  // Physics
  function step(dt){ if (mode!=='play') return; integrate(dt); }

  function integrate(dt){
    ball.vel.y += phys.g * dt;

    let sub = Math.max(1, Math.ceil((Math.abs(ball.vel.x)+Math.abs(ball.vel.y)) * dt / 400));
    sub = Math.min(phys.maxSub, sub);
    const speed = Math.hypot(ball.vel.x, ball.vel.y);
    const maxMove = ball.r / 3;
    const need = speed > 0 ? Math.ceil((speed * dt) / maxMove) : 1;
    sub = Math.max(sub, Math.min(64, need));
    const h = dt / sub;

    const segs = buildSegments();

    for (let k=0;k<sub;k++){
      // gravity strokes attraction each microstep
      if (segs.length){ let ax=0, ay=0; for (const s of segs){ if (s.type!=='gravity') continue; const q=nearestOnSeg(ball.pos, s.a, s.b); const dx=q.x-ball.pos.x, dy=q.y-ball.pos.y; const d=Math.hypot(dx,dy); if (d<phys.gravityRange && d>1){ const w = 1 - d/phys.gravityRange; const mag = phys.gravityStrength * w; ax += (dx/d)*mag; ay += (dy/d)*mag; } } ball.vel.x += ax*h; ball.vel.y += ay*h; }

      // integrate
      ball.pos.x += ball.vel.x*h;
      ball.pos.y += ball.vel.y*h;

      // resolve collisions iteratively
      for (let iter=0; iter<3; iter++){
        let hit = false;
        for (let i=0;i<segs.length;i++){
          const {a,b,type} = segs[i];
          const q = nearestOnSeg(ball.pos, a, b);
          const dx = ball.pos.x - q.x, dy = ball.pos.y - q.y; const d2 = dx*dx + dy*dy; const r = ball.r;
          if (d2 < r*r){
            hit = true;
            const d = Math.sqrt(d2)||1; const nx = dx/d, ny = dy/d;
            const pen = r - d + 0.001; ball.pos.x += nx*pen; ball.pos.y += ny*pen;
            const tx = b.x-a.x, ty=b.y-a.y; const tl = Math.hypot(tx,ty)||1; const tnx = tx/tl, tny=ty/tl;
            let vn = ball.vel.x*nx + ball.vel.y*ny; let vt = ball.vel.x*tnx + ball.vel.y*tny;
            if (vn < 0) vn = -vn * phys.restitution; else vn *= 0.98;
            vt *= Math.max(0, 1 - phys.fric*h*6);
            vt += phys.g * (tny) * phys.slopeGain * h;
            if (tny < 0) vt *= Math.max(0, 1 - phys.uphillDamp * (-tny) * h);
            if (type==='boost') vt += phys.boostAccel * h;
            if (type==='brake') vt *= Math.max(0, 1 - phys.brakeRate * h);
            if (type==='gravity') { vn *= 0.9; vt *= 0.98; }
            ball.vel.x = vn*nx + vt*tnx; ball.vel.y = vn*ny + vt*tny;
          }
        }
        if (!hit) break;
      }

      // bounds
      const pad = phys.worldPad; const minx=-pad, miny=-pad, maxx=pad+innerWidth, maxy=pad+innerHeight;
      if (ball.pos.x < minx+ball.r){ ball.pos.x=minx+ball.r; ball.vel.x = Math.abs(ball.vel.x)*phys.restitution; }
      if (ball.pos.x > maxx-ball.r){ ball.pos.x=maxx-ball.r; ball.vel.x = -Math.abs(ball.vel.x)*phys.restitution; }
      if (ball.pos.y < miny+ball.r){ ball.pos.y=miny+ball.r; ball.vel.y = Math.abs(ball.vel.y)*phys.restitution; }
      if (ball.pos.y > maxy-ball.r){ ball.pos.y=maxy-ball.r; ball.vel.y = -Math.abs(ball.vel.y)*phys.restitution; }
    }

    if (endMarker && dist(ball.pos, endMarker) < ball.r+10){ finishBadge.style.display='inline-block'; mode='draw'; }
  }

  // Render
  function render(){
    resize();
    ctx.save(); ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.scale(DPR, DPR);
    ctx.save(); ctx.scale(view.scale, view.scale); ctx.translate(-view.x, -view.y);

    // strokes
    ctx.lineJoin='round'; ctx.lineCap='round';
    for (const s of strokes){
      if (!s.points || s.points.length<2) continue;
      ctx.beginPath(); ctx.moveTo(s.points[0].x, s.points[0].y);
      for (let i=1;i<s.points.length;i++) ctx.lineTo(s.points[i].x, s.points[i].y);
      ctx.lineWidth = 6;
      ctx.strokeStyle = (s.type==='boost'? '#ef4444' : s.type==='brake'? '#f59e0b' : s.type==='gravity'? '#a78bfa' : '#60a5fa');
      ctx.stroke();
    }

    // preview
    ctx.globalAlpha = 0.45;
    if (drawing && tempPoints && tempPoints.length>1){
      ctx.beginPath(); ctx.moveTo(tempPoints[0].x, tempPoints[0].y);
      for (let i=1;i<tempPoints.length;i++) ctx.lineTo(tempPoints[i].x, tempPoints[i].y);
      ctx.lineWidth=6; ctx.strokeStyle = (effect==='boost'? '#ef4444' : effect==='brake'? '#f59e0b' : effect==='gravity'? '#a78bfa' : '#60a5fa');
      ctx.stroke();
    }
    if ((tool==='arcc' || tool==='arco') && arcStage>0){
      let pts=null; if (arcStage===1){ pts=[arcS, arcE]; } else if (arcStage===2){ pts = (tool==='arcc')? circleArcFromSEV(arcS, arcE, arcV, 60) : ovalArcFromSEV(arcS, arcE, arcV, 60); }
      if (pts && pts.length>1){ ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y); for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y); ctx.lineWidth=6; ctx.strokeStyle = (effect==='boost'? '#ef4444' : effect==='brake'? '#f59e0b' : effect==='gravity'? '#a78bfa' : '#60a5fa'); ctx.stroke(); }
    }
    ctx.globalAlpha = 1;

    // markers
    if (startMarker){ ctx.fillStyle = '#f472b6'; }
    if (startMarker){ ctx.fillStyle='#f472b6'; ctx.beginPath(); ctx.arc(startMarker.x, startMarker.y, 5, 0, Math.PI*2); ctx.fill(); }
    if (endMarker){ ctx.fillStyle='#34d399'; ctx.beginPath(); ctx.arc(endMarker.x, endMarker.y, 6, 0, Math.PI*2); ctx.fill(); }

    // ball + trail
    if (mode==='play'){ ball.trail.push({x:ball.pos.x,y:ball.pos.y}); if (ball.trail.length>500) ball.trail.shift(); }
    else { ball.trail.length=0; }

    ctx.fillStyle = 'rgba(253,224,71,0.4)';
    for (let i=Math.max(0,ball.trail.length-120); i<ball.trail.length; i++){ const p = ball.trail[i]; ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill(); }

    ctx.fillStyle='#fde047'; ctx.beginPath(); ctx.arc(ball.pos.x, ball.pos.y, ball.r, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle='#a16207'; ctx.lineWidth=2; ctx.stroke();

    ctx.restore(); ctx.restore();
  }

  // Loop
  let last = performance.now();
  const fpsCounter = { acc:0, n:0, fps:0, update(dt){ this.acc+=dt; this.n++; if (this.acc>=0.5){ this.fps=this.n/this.acc; this.acc=0; this.n=0; } } };

  function loop(ts){ try { const dt = Math.min(0.033, (ts-last)/1000); last = ts; step(dt); render(); fpsCounter.update(dt); fpsOut.textContent = fpsCounter.fps.toFixed(0); } catch(ex){ errBox.textContent = 'Fehler im Loop: ' + ex.message; errBox.style.display='block'; } requestAnimationFrame(loop); }

  // Init
  function init(){ resize(); updateButtons(); ball.pos={...startMarker}; }
  function updateButtons(){
    drawBtn.setAttribute('aria-pressed', String(mode==='draw'));
    playBtn.setAttribute('aria-pressed', String(mode==='play'));
    moveBtn.setAttribute('aria-pressed', String(mode==='move'));
    startBtn.setAttribute('aria-pressed', String(mode==='setstart'));
    endBtn.setAttribute('aria-pressed', String(mode==='setend'));

    toolFree.setAttribute('aria-pressed', String(tool==='free'));
    toolLine.setAttribute('aria-pressed', String(tool==='line'));
    toolArcC.setAttribute('aria-pressed', String(tool==='arcc'));
    toolArcO.setAttribute('aria-pressed', String(tool==='arco'));
    toolErase.setAttribute('aria-pressed', String(tool==='eraser'));

    effNeutral.setAttribute('aria-pressed', String(effect==='neutral'));
    effBoost.setAttribute('aria-pressed', String(effect==='boost'));
    effBrake.setAttribute('aria-pressed', String(effect==='brake'));
    effGrav.setAttribute('aria-pressed', String(effect==='gravity'));
  }

  init();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
