<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Line Rider – Stable Fix (UI bedienbar + Zeichnen)</title>
  <style>
    :root{ --bg:#0b0e14; --panel:#121722; --ink:#e8e8e8; --b:#1f2533; --blue:#60a5fa; --red:#ef4444; --yellow:#f59e0b; --vio:#a78bfa; --good:#34d399; --pink:#f472b6; }
    html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    body{user-select:none}
    #canvas{position:fixed;inset:0;width:100vw;height:100dvh;display:block;touch-action:none;background:#000;z-index:0}
    #ui{position:fixed;left:12px;top:12px;display:flex;flex-wrap:wrap;gap:8px;z-index:1000}
    .group{display:flex;gap:6px;background:#0f1420;border:1px solid var(--b);padding:6px;border-radius:12px;align-items:center}
    .btn{background:var(--panel);border:1px solid var(--b);color:var(--ink);padding:8px 10px;border-radius:10px;cursor:pointer;font-size:14px}
    .btn[aria-pressed="true"]{outline:2px solid #59c}
    .btn.small{padding:6px 8px;font-size:12px}
    .swatch{width:12px;height:12px;border-radius:3px;display:inline-block;border:1px solid var(--b)}
    #hud{position:fixed;right:12px;top:12px;background:var(--panel);padding:8px 10px;border-radius:10px;border:1px solid var(--b);font-size:12px;opacity:.9;z-index:1000}
    #helpModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:1200}
    #helpBox{background:var(--panel);border:1px solid var(--b);border-radius:12px;max-width:min(92vw,640px);padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.4)}
    .badge{padding:2px 6px;border-radius:6px;border:1px solid var(--b);background:#0f1420;margin-left:6px;font-size:11px}
    #err{position:fixed;left:12px;bottom:12px;background:#7f1d1d;color:#fee;padding:8px 10px;border-radius:8px;border:1px solid #991b1b;display:none;z-index:1300;max-width:min(90vw,520px);font-size:12px;white-space:pre-wrap}
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="ui">
    <div class="group" role="toolbar" aria-label="Modes">
      <button class="btn" id="drawBtn" aria-pressed="true">Draw</button>
      <button class="btn" id="playBtn">Play</button>
      <button class="btn" id="moveBtn">Move</button>
      <button class="btn" id="startBtn">Set Start</button>
      <button class="btn" id="endBtn">Set End</button>
      <button class="btn" id="resetBtn">Reset</button>
    </div>
    <div class="group" role="toolbar" aria-label="Tools">
      <button class="btn" id="toolFree" aria-pressed="true">Freihand</button>
      <button class="btn" id="toolLine">Gerade</button>
      <button class="btn" id="toolArcC">Kreisbogen</button>
      <button class="btn" id="toolArcO">Ovalbogen</button>
      <button class="btn" id="toolErase">Eraser</button>
    </div>
    <div class="group" role="toolbar" aria-label="Effect">
      <span>Effekt:</span>
      <button class="btn" id="effNeutral" aria-pressed="true">Neutral <span class="swatch" style="background:var(--blue)"></span></button>
      <button class="btn" id="effBoost">Boost <span class="swatch" style="background:var(--red)"></span></button>
      <button class="btn" id="effBrake">Brake <span class="swatch" style="background:var(--yellow)"></span></button>
      <button class="btn" id="effGrav">Gravity <span class="swatch" style="background:var(--vio)"></span></button>
    </div>
    <div class="group" role="toolbar" aria-label="Help">
      <button class="btn" id="helpBtn">Tastaturbelegung</button>
    </div>
  </div>

  <div id="helpModal">
    <div id="helpBox">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:8px">
        <strong>Steuerung & Tastatur</strong>
        <button class="btn small" id="helpClose">Schließen</button>
      </div>
      <div style="font-size:13px;line-height:1.6;color:#cbd5e1">
        <p><b>Modi:</b> D = Draw, P = Play, M = Move, S = Set Start, E = Set End, R = Reset</p>
        <p><b>Tools:</b> F = Freihand, L = Gerade, C = Kreisbogen, O = Ovalbogen, X = Eraser</p>
        <p><b>Effekte:</b> 1 = Neutral, 2 = Boost, 3 = Brake, 4 = Gravity</p>
        <p><b>Zoom & Pan:</b> Im Move‑Modus Zwei‑Finger‑Pinch, Ein‑Finger‑Pan; Desktop: Mausrad = Zoom</p>
        <p><b>Shortcut:</b> H oder ? öffnet/schließt dieses Fenster</p>
      </div>
    </div>
  </div>

  <div id="hud">FPS: <span id="fps">0</span> <span id="finish" class="badge" style="display:none">Goal!</span></div>
  <div id="err"></div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.floor(devicePixelRatio || 1));
  const errBox = document.getElementById('err');

  // show runtime errors
  window.addEventListener('error', (e)=>{ errBox.textContent = 'Fehler: '+ e.message; errBox.style.display='block'; });

  // UI refs
  const $ = id => document.getElementById(id);
  const drawBtn=$('drawBtn'), playBtn=$('playBtn'), moveBtn=$('moveBtn'), startBtn=$('startBtn'), endBtn=$('endBtn'), resetBtn=$('resetBtn');
  const toolFree=$('toolFree'), toolLine=$('toolLine'), toolArcC=$('toolArcC'), toolArcO=$('toolArcO'), toolErase=$('toolErase');
  const effNeutral=$('effNeutral'), effBoost=$('effBoost'), effBrake=$('effBrake'), effGrav=$('effGrav');
  const helpBtn=$('helpBtn'), helpModal=$('helpModal'), helpClose=$('helpClose');
  const fpsOut=$('fps'), finishBadge=$('finish');

  // State
  let mode='draw'; // 'draw' | 'play' | 'move' | 'setstart' | 'setend'
  let tool='free'; // 'free' | 'line' | 'arcc' | 'arco' | 'eraser'
  let effect='neutral'; // 'neutral' | 'boost' | 'brake' | 'gravity'

  const view={x:0,y:0,scale:1};

  // Data
  let strokes=[]; // {type, points, shape}
  let drawing=false, tempPoints=null;
  let arcStage=0, arcS=null, arcE=null, arcV=null;

  // Ball & physics
  const ball={r:10,pos:{x:200,y:200},vel:{x:0,y:0},trail:[]};
  const phys={g:30,restitution:0.4,fric:0.04,slopeGain:1.2,uphillDamp:1.2,boostAccel:2400,brakeRate:2.2,gravityRange:140,gravityStrength:1800,maxSub:16,worldPad:2000};

  let startMarker={x:130,y:190}; let endMarker=null;

  // Helpers
  function resize(){ const w=Math.floor(innerWidth*DPR), h=Math.floor((innerHeight||document.documentElement.clientHeight)*DPR); if (canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h; } }
  function worldPt(px,py){ const r=canvas.getBoundingClientRect(); const x=(px-r.left)*canvas.width/r.width, y=(py-r.top)*canvas.height/r.height; return {x:(x/DPR)/view.scale+view.x, y:(y/DPR)/view.scale+view.y}; }
  const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
  function mix(a,b,t){ return {x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t}; }
  function nearestOnSeg(p,a,b){ const abx=b.x-a.x, aby=b.y-a.y; const ab2=abx*abx+aby*aby||1; const apx=p.x-a.x, apy=p.y-a.y; let t=(apx*abx+apy*aby)/ab2; t=Math.max(0,Math.min(1,t)); return {x:a.x+abx*t,y:a.y+aby*t,t}; }

  function circleArcFromSEV(S,E,V,samples=48){ const x1=S.x,y1=S.y,x2=E.x,y2=E.y,x3=V.x,y3=V.y; const a=x1*(y2-y3)-y1*(x2-x3)+x2*y3-x3*y2; const b=(x1*x1+y1*y1)*(y3-y2)+(x2*x2+y2*y2)*(y1-y3)+(x3*x3+y3*y3)*(y2-y1); const c=(x1*x1+y1*y1)*(x2-x3)+(x2*x2+y2*y2)*(x3-x1)+(x3*x3+y3*y3)*(x1-x2); const d=(x1*x1+y1*y1)*(x3*y2-x2*y3)+(x2*x2+y2*y2)*(x1*y3-x3*y1)+(x3*x3+y3*y3)*(x2*y1-x1*y2); if (Math.abs(a)<1e-6){ return [S,E]; } const cx=-b/(2*a), cy=-c/(2*a); const ang=p=>Math.atan2(p.y-cy,p.x-cx); let a1=ang(S), a2=ang(E), av=ang(V); function norm(d){ while(d<=-Math.PI)d+=2*Math.PI; while(d>Math.PI)d-=2*Math.PI; return d; } let d12=norm(a2-a1), d1v=norm(av-a1); let dir=Math.sign(d12)||1; if ((dir>0 && !(d1v>=0 && d1v<=Math.abs(d12))) || (dir<0 && !(d1v<=0 && d1v>=-Math.abs(d12)))) dir=-dir; const out=[]; for (let i=0;i<=samples;i++){ const t=i/samples; const angt=a1+dir*Math.abs(d12)*t; out.push({x:cx+Math.cos(angt)*dist(S,{x:cx,y:cy}), y:cy+Math.sin(angt)*dist(S,{x:cx,y:cy})}); } return out; }
  function ovalArcFromSEV(S,E,V,samples=48){ const M=mix(S,E,0.5); const dx=E.x-S.x, dy=E.y-S.y; const L=Math.hypot(dx,dy)||1; const ux=dx/L, uy=dy/L; const px=-uy, py=ux; const vRel={x:V.x-M.x,y:V.y-M.y}; const b=Math.abs(vRel.x*px+vRel.y*py); const a=L/2; const sign=Math.sign(vRel.x*px+vRel.y*py)||1; const out=[]; for (let i=0;i<=samples;i++){ const t=-1+2*i/samples; const ex=M.x+t*a*ux+sign*(b*Math.sqrt(Math.max(0,1-t*t)))*px; const ey=M.y+t*a*uy+sign*(b*Math.sqrt(Math.max(0,1-t*t)))*py; out.push({x:ex,y:ey}); } return out; }

  function buildSegments(){ const segs=[]; for (let si=0; si<strokes.length; si++){ const s=strokes[si]; const P=s.points; if (!P||P.length<2) continue; for (let i=0;i<P.length-1;i++) segs.push({a:P[i],b:P[i+1],type:s.type}); } return segs; }

  // ===== UI Handlers (ohne Delegation, maximal kompatibel) =====
  drawBtn.onclick=()=>{ mode='draw'; updateButtons(); };
  playBtn.onclick=()=>{ mode='play'; ball.pos={...startMarker}; ball.vel={x:0,y:0}; finishBadge.style.display='none'; updateButtons(); };
  moveBtn.onclick=()=>{ mode='move'; updateButtons(); };
  startBtn.onclick=()=>{ mode='setstart'; updateButtons(); };
  endBtn.onclick=()=>{ mode='setend'; updateButtons(); };
  resetBtn.onclick=()=>{ ball.pos={...startMarker}; ball.vel={x:0,y:0}; ball.trail=[]; finishBadge.style.display='none'; };

  toolFree.onclick=()=>{ tool='free'; arcStage=0; updateButtons(); };
  toolLine.onclick=()=>{ tool='line'; arcStage=0; updateButtons(); };
  toolArcC.onclick=()=>{ tool='arcc'; arcStage=0; updateButtons(); };
  toolArcO.onclick=()=>{ tool='arco'; arcStage=0; updateButtons(); };
  toolErase.onclick=()=>{ tool='eraser'; arcStage=0; updateButtons(); };

  effNeutral.onclick=()=>{ effect='neutral'; updateButtons(); };
  effBoost.onclick=()=>{ effect='boost'; updateButtons(); };
  effBrake.onclick=()=>{ effect='brake'; updateButtons(); };
  effGrav.onclick=()=>{ effect='gravity'; updateButtons(); };

  helpBtn.onclick=()=>{ helpModal.style.display='flex'; };
  helpClose.onclick=()=>{ helpModal.style.display='none'; };
  helpModal.addEventListener('click', (e)=>{ if (e.target===helpModal) helpModal.style.display='none'; });

  // Keyboard shortcuts
  window.addEventListener('keydown',(e)=>{
    const k=e.key||''; if (!k) return;
    if (k==='?'||k.toLowerCase()==='h'){ helpModal.style.display = (helpModal.style.display==='flex'?'none':'flex'); return; }
    const c=k.toLowerCase();
    if (c==='d'){ mode='draw'; }
    else if (c==='p'){ mode='play'; ball.pos={...startMarker}; ball.vel={x:0,y:0}; finishBadge.style.display='none'; }
    else if (c==='m'){ mode='move'; }
    else if (c==='s'){ mode='setstart'; }
    else if (c==='e'){ mode='setend'; }
    else if (c==='r'){ ball.pos={...startMarker}; ball.vel={x:0,y:0}; ball.trail=[]; finishBadge.style.display='none'; }
    else if (c==='f'){ tool='free'; arcStage=0; }
    else if (c==='l'){ tool='line'; arcStage=0; }
    else if (c==='c'){ tool='arcc'; arcStage=0; }
    else if (c==='o'){ tool='arco'; arcStage=0; }
    else if (c==='x'){ tool='eraser'; arcStage=0; }
    else if (c==='1'){ effect='neutral'; }
    else if (c==='2'){ effect='boost'; }
    else if (c==='3'){ effect='brake'; }
    else if (c==='4'){ effect='gravity'; }
    else return;
    updateButtons();
  });

  // ===== Canvas Input (ohne PointerCapture, damit UI nie blockiert) =====
  const pointers=new Map();
  const pinch={active:false,d:0,mid:{x:0,y:0}};

  canvas.addEventListener('pointerdown',(e)=>{
    // nur reagieren, wenn wirklich auf dem Canvas getippt wurde
    if (e.target!==canvas) return;
    e.preventDefault();
    pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});

    if (mode==='draw'){
      const w=worldPt(e.clientX,e.clientY);
      if (tool==='free'){ drawing=true; tempPoints=[w]; }
      else if (tool==='line'){ drawing=true; tempPoints=[w,w]; }
      else if (tool==='arcc' || tool==='arco'){ if (arcStage===0){ arcS=w; arcE=w; arcV=w; arcStage=1; } }
      else if (tool==='eraser'){ eraseAt(w); }
    } else if (mode==='setstart'){
      const w=worldPt(e.clientX,e.clientY); startMarker={x:w.x,y:w.y}; mode='draw'; updateButtons();
    } else if (mode==='setend'){
      const w=worldPt(e.clientX,e.clientY); endMarker={x:w.x,y:w.y}; mode='draw'; updateButtons();
    } else if (mode==='move'){
      if (pointers.size===2){ const pts=[...pointers.values()]; const dx=pts[0].x-pts[1].x, dy=pts[0].y-pts[1].y; pinch.d=Math.hypot(dx,dy)||1; pinch.mid={x:(pts[0].x+pts[1].x)/2,y:(pts[0].y+pts[1].y)/2}; pinch.active=true; }
    }
  }, {passive:false});

  canvas.addEventListener('pointermove',(e)=>{
    if (e.target!==canvas) return;
    const prev=pointers.get(e.pointerId); pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
    const w=worldPt(e.clientX,e.clientY);

    if (mode==='draw'){
      if (tool==='free' && drawing && tempPoints){ const last=tempPoints[tempPoints.length-1]; const dx=w.x-last.x, dy=w.y-last.y; if (dx*dx+dy*dy>4) tempPoints.push(w); }
      else if (tool==='line' && drawing && tempPoints){ tempPoints[1]=w; }
      else if (tool==='arcc'){ if (arcStage===1){ arcE=w; } else if (arcStage===2){ arcV=w; } }
      else if (tool==='arco'){ if (arcStage===1){ arcE=w; } else if (arcStage===2){ arcV=w; } }
    } else if (mode==='move'){
      if (pointers.size>=2){ const pts=[...pointers.values()]; const dx=pts[0].x-pts[1].x, dy=pts[0].y-pts[1].y; const dist=Math.hypot(dx,dy)||1; const mid={x:(pts[0].x+pts[1].x)/2,y:(pts[0].y+pts[1].y)/2}; if (pinch.active){ view.x-=(mid.x-pinch.mid.x)/view.scale; view.y-=(mid.y-pinch.mid.y)/view.scale; } const wb=worldPt(mid.x,mid.y); const factor=pinch.active?(dist/pinch.d):1; view.scale=Math.max(0.2,Math.min(4,view.scale*factor)); const wa=worldPt(mid.x,mid.y); view.x+=(wb.x-wa.x); view.y+=(wb.y-wa.y); pinch.d=dist; pinch.mid=mid; pinch.active=true; } else if (prev){ const dx=e.clientX-prev.x, dy=e.clientY-prev.y; view.x-=dx/view.scale; view.y-=dy/view.scale; pinch.active=false; }
    }
  });

  canvas.addEventListener('pointerup',(e)=>{
    if (e.target!==canvas) return;
    pointers.delete(e.pointerId);
    const w=worldPt(e.clientX,e.clientY);
    if (mode==='draw'){
      if (tool==='free' && drawing && tempPoints){ if (tempPoints.length>1) strokes.push({type:effect, points:tempPoints.slice(), shape:'poly'}); drawing=false; tempPoints=null; }
      else if (tool==='line' && drawing && tempPoints){ const pts=[tempPoints[0],tempPoints[1]]; if (dist(pts[0],pts[1])>2) strokes.push({type:effect, points:pts, shape:'poly'}); drawing=false; tempPoints=null; }
      else if (tool==='arcc'){ if (arcStage===1){ arcE=w; arcStage=2; arcV=mix(arcS,arcE,0.5); } else if (arcStage===2){ arcV=w; const pts=circleArcFromSEV(arcS,arcE,arcV,60); if (pts.length>1) strokes.push({type:effect, points:pts, shape:'arcC'}); arcStage=0; } }
      else if (tool==='arco'){ if (arcStage===1){ arcE=w; arcStage=2; arcV=mix(arcS,arcE,0.5); } else if (arcStage===2){ arcV=w; const pts=ovalArcFromSEV(arcS,arcE,arcV,60); if (pts.length>1) strokes.push({type:effect, points:pts, shape:'arcO'}); arcStage=0; } }
    } else if (mode==='move'){ if (pointers.size<2) pinch.active=false; }
  });
  canvas.addEventListener('pointercancel',()=>{ pointers.clear(); drawing=false; tempPoints=null; arcStage=0; pinch.active=false; });

  // wheel zoom (desktop)
  canvas.addEventListener('wheel',(e)=>{ e.preventDefault(); const factor=Math.pow(1.0015,-e.deltaY); const mx=e.clientX,my=e.clientY; const before=worldPt(mx,my); view.scale=Math.max(0.2,Math.min(4,view.scale*factor)); const after=worldPt(mx,my); view.x+=(before.x-after.x); view.y+=(before.y-after.y); }, {passive:false});

  function eraseAt(w){ const threshold=12; let best={si:-1,d2:Infinity}; for (let si=0; si<strokes.length; si++){ const P=strokes[si].points; for (let i=0;i<P.length-1;i++){ const q=nearestOnSeg(w,P[i],P[i+1]); const dx=w.x-q.x, dy=w.y-q.y; const d2=dx*dx+dy*dy; if (d2<best.d2){ best={si,d2}; } } } if (best.si>=0 && best.d2<threshold*threshold){ strokes.splice(best.si,1); } }

  function updateButtons(){ drawBtn.setAttribute('aria-pressed', String(mode==='draw')); playBtn.setAttribute('aria-pressed', String(mode==='play')); moveBtn.setAttribute('aria-pressed', String(mode==='move')); startBtn.setAttribute('aria-pressed', String(mode==='setstart')); endBtn.setAttribute('aria-pressed', String(mode==='setend')); toolFree.setAttribute('aria-pressed', String(tool==='free')); toolLine.setAttribute('aria-pressed', String(tool==='line')); toolArcC.setAttribute('aria-pressed', String(tool==='arcc')); toolArcO.setAttribute('aria-pressed', String(tool==='arco')); toolErase.setAttribute('aria-pressed', String(tool==='eraser')); effNeutral.setAttribute('aria-pressed', String(effect==='neutral')); effBoost.setAttribute('aria-pressed', String(effect==='boost')); effBrake.setAttribute('aria-pressed', String(effect==='brake')); effGrav.setAttribute('aria-pressed', String(effect==='gravity')); }

  // Physics
  function step(dt){ if (mode!=='play') return; integrate(dt); }
  function integrate(dt){ ball.vel.y += phys.g*dt; let sub=Math.max(1, Math.ceil((Math.abs(ball.vel.x)+Math.abs(ball.vel.y))*dt/400)); sub=Math.min(phys.maxSub, sub); const speed=Math.hypot(ball.vel.x,ball.vel.y); const maxMove=ball.r/3; const need=speed>0?Math.ceil((speed*dt)/maxMove):1; sub=Math.max(sub, Math.min(64,need)); const h=dt/sub; const segs=buildSegments(); for (let k=0;k<sub;k++){ // gravity attraction
      if (segs.length){ let ax=0, ay=0; for (const s of segs){ if (s.type!=='gravity') continue; const q=nearestOnSeg(ball.pos,s.a,s.b); const dx=q.x-ball.pos.x, dy=q.y-ball.pos.y; const d=Math.hypot(dx,dy); if (d<phys.gravityRange && d>1){ const w=1-d/phys.gravityRange; const mag=phys.gravityStrength*w; ax+=(dx/d)*mag; ay+=(dy/d)*mag; } } ball.vel.x+=ax*h; ball.vel.y+=ay*h; }
      ball.pos.x+=ball.vel.x*h; ball.pos.y+=ball.vel.y*h; // collisions iter
      for (let iter=0; iter<3; iter++){ let hit=false; for (let i=0;i<segs.length;i++){ const {a,b,type}=segs[i]; const q=nearestOnSeg(ball.pos,a,b); const dx=ball.pos.x-q.x, dy=ball.pos.y-q.y; const d2=dx*dx+dy*dy; if (d2<ball.r*ball.r){ hit=true; const d=Math.sqrt(d2)||1; const nx=dx/d, ny=dy/d; const pen=ball.r-d+0.001; ball.pos.x+=nx*pen; ball.pos.y+=ny*pen; const tx=b.x-a.x, ty=b.y-a.y; const tl=Math.hypot(tx,ty)||1; const tnx=tx/tl, tny=ty/tl; let vn=ball.vel.x*nx+ball.vel.y*ny; let vt=ball.vel.x*tnx+ball.vel.y*tny; if (vn<0) vn=-vn*phys.restitution; else vn*=0.98; vt*=Math.max(0,1-phys.fric*h*6); vt+=phys.g*(tny)*phys.slopeGain*h; if (tny<0) vt*=Math.max(0,1-phys.uphillDamp*(-tny)*h); if (type==='boost') vt+=phys.boostAccel*h; if (type==='brake') vt*=Math.max(0,1-phys.brakeRate*h); if (type==='gravity'){ vn*=0.9; vt*=0.98; } ball.vel.x=vn*nx+vt*tnx; ball.vel.y=vn*ny+vt*tny; } } if (!hit) break; }
      // bounds
      const pad=phys.worldPad; const minx=-pad, miny=-pad, maxx=pad+innerWidth, maxy=pad+innerHeight; if (ball.pos.x<minx+ball.r){ ball.pos.x=minx+ball.r; ball.vel.x=Math.abs(ball.vel.x)*phys.restitution; } if (ball.pos.x>maxx-ball.r){ ball.pos.x=maxx-ball.r; ball.vel.x=-Math.abs(ball.vel.x)*phys.restitution; } if (ball.pos.y<miny+ball.r){ ball.pos.y=miny+ball.r; ball.vel.y=Math.abs(ball.vel.y)*phys.restitution; } if (ball.pos.y>maxy-ball.r){ ball.pos.y=maxy-ball.r; ball.vel.y=-Math.abs(ball.vel.y)*phys.restitution; }
    }
    if (endMarker && dist(ball.pos, endMarker) < ball.r+10){ finishBadge.style.display='inline-block'; mode='draw'; updateButtons(); }
  }

  // Render
  function render(){ resize(); ctx.save(); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.scale(DPR,DPR); ctx.save(); ctx.scale(view.scale,view.scale); ctx.translate(-view.x,-view.y);
    // strokes
    ctx.lineJoin='round'; ctx.lineCap='round';
    for (const s of strokes){ if (!s.points||s.points.length<2) continue; ctx.beginPath(); ctx.moveTo(s.points[0].x,s.points[0].y); for (let i=1;i<s.points.length;i++) ctx.lineTo(s.points[i].x,s.points[i].y); ctx.lineWidth=6; ctx.strokeStyle=(s.type==='boost'?'#ef4444': s.type==='brake'?'#f59e0b': s.type==='gravity'?'#a78bfa':'#60a5fa'); ctx.stroke(); }
    // preview
    ctx.globalAlpha=0.45; if (drawing && tempPoints && tempPoints.length>1){ ctx.beginPath(); ctx.moveTo(tempPoints[0].x,tempPoints[0].y); for (let i=1;i<tempPoints.length;i++) ctx.lineTo(tempPoints[i].x,tempPoints[i].y); ctx.lineWidth=6; ctx.strokeStyle=(effect==='boost'?'#ef4444': effect==='brake'?'#f59e0b': effect==='gravity'?'#a78bfa':'#60a5fa'); ctx.stroke(); }
    if ((tool==='arcc'||tool==='arco') && arcStage>0){ let pts=null; if (arcStage===1){ pts=[arcS,arcE]; } else if (arcStage===2){ pts=(tool==='arcc')?circleArcFromSEV(arcS,arcE,arcV,60):ovalArcFromSEV(arcS,arcE,arcV,60); } if (pts && pts.length>1){ ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y); for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x,pts[i].y); ctx.lineWidth=6; ctx.strokeStyle=(effect==='boost'?'#ef4444': effect==='brake'?'#f59e0b': effect==='gravity'?'#a78bfa':'#60a5fa'); ctx.stroke(); }} ctx.globalAlpha=1;
    // markers
    if (startMarker){ ctx.fillStyle = '#f472b6'; ctx.beginPath(); ctx.arc(startMarker.x,startMarker.y,5,0,Math.PI*2); ctx.fill(); }
    if (endMarker){ ctx.fillStyle = '#34d399'; ctx.beginPath(); ctx.arc(endMarker.x,endMarker.y,6,0,Math.PI*2); ctx.fill(); }
    // ball + trail
    if (mode==='play'){ ball.trail.push({x:ball.pos.x,y:ball.pos.y}); if (ball.trail.length>500) ball.trail.shift(); } else { ball.trail.length=0; }
    ctx.fillStyle='rgba(253,224,71,0.4)'; for (let i=Math.max(0,ball.trail.length-120); i<ball.trail.length; i++){ const p=ball.trail[i]; ctx.beginPath(); ctx.arc(p.x,p.y,2,0,Math.PI*2); ctx.fill(); }
    ctx.fillStyle='#fde047'; ctx.beginPath(); ctx.arc(ball.pos.x,ball.pos.y,ball.r,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#a16207'; ctx.lineWidth=2; ctx.stroke();
    ctx.restore(); ctx.restore(); }

  // Loop
  let last=performance.now(); const fpsCounter={acc:0,n:0,fps:0,update(dt){ this.acc+=dt; this.n++; if (this.acc>=0.5){ this.fps=this.n/this.acc; this.acc=0; this.n=0; } }};
  function loop(ts){ try{ const dt=Math.min(0.033,(ts-last)/1000); last=ts; step(dt); render(); fpsCounter.update(dt); fpsOut.textContent=fpsCounter.fps.toFixed(0); } catch(ex){ errBox.textContent='Fehler im Loop: '+ex.message; errBox.style.display='block'; } requestAnimationFrame(loop); }

  function init(){ resize(); updateButtons(); ball.pos={...startMarker}; }
  init();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
